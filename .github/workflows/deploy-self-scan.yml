name: Deploy Self-Scan Workflow

on:
  workflow_dispatch:
    inputs:
      repos:
        description: "Comma/whitespace-separated repo names (repo or owner/repo)"
        required: true
        type: string
      source_path:
        description: "Path of the source workflow file"
        required: false
        default: .github/workflows/self-scan.yml
        type: string
      target_path:
        description: "Target path in destination repos"
        required: false
        default: .github/workflows/self-scan.yml
        type: string
      pr_title:
        description: "PR title"
        required: false
        default: "chore: add self-scan workflow"
        type: string
      pr_body:
        description: "PR body"
        required: false
        default: "Add automated security scanning workflow for this repository."
        type: string
      dry_run:
        description: "If true, only list actions without creating PRs"
        required: false
        default: "false"
        type: choice
        options: ["true", "false"]

permissions:
  id-token: write
  contents: read
  pull-requests: write
  issues: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy workflow to repos
        uses: actions/github-script@v7
        env:
          REPOS: ${{ inputs.repos }}
          SOURCE_PATH: ${{ inputs.source_path }}
          TARGET_PATH: ${{ inputs.target_path }}
          PR_TITLE: ${{ inputs.pr_title }}
          PR_BODY: ${{ inputs.pr_body }}
          DRY_RUN: ${{ inputs.dry_run }}
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const wfInputs = (context.payload && context.payload.inputs) || {};
            const read = (k, d='') => (wfInputs[k] ?? process.env[k.toUpperCase()] ?? d);

            const splitList = (s) => String(s || '')
              .split(/[\s,]+/)
              .map(x => x.trim())
              .filter(Boolean);

            const repoList = splitList(read('repos', ''));
            const sourcePath = read('source_path', '.github/workflows/self-scan.yml');
            const targetPath = read('target_path', '.github/workflows/self-scan.yml');
            const prTitle    = read('pr_title', 'chore: add self-scan workflow');
            const prBody     = read('pr_body', 'Add automated security scanning workflow for this repository.');
            const dryRun     = String(read('dry_run', 'false')) === 'true';

            if (!repoList.length) {
              core.setFailed('No repos specified');
              process.exit(1);
            }

            // Read source file
            let content;
            try {
              content = fs.readFileSync(path.resolve(process.cwd(), sourcePath), 'utf8');
            } catch {
              core.setFailed(`Source file not found at: ${sourcePath}`);
              process.exit(1);
            }
            const b64 = Buffer.from(content, 'utf8').toString('base64');

            const normalise = (arr) => arr.map(x => {
              const lower = x.toLowerCase();
              const p = lower.split('/');
              if (p.length === 2) return { owner: p[0], name: p[1], full: lower };
              // If no owner specified, use the current repo owner as default
              return { owner: context.repo.owner.toLowerCase(), name: lower, full: `${context.repo.owner.toLowerCase()}/${lower}` };
            });

            const repos = normalise(repoList);

            await core.summary
              .addHeading('Deployment Configuration', 2)
              .addList([
                `Repos to deploy: ${repos.map(r=>r.full).join(', ')}`,
                `Source: ${sourcePath}`,
                `Target: ${targetPath}`,
                `Dry run: ${dryRun}`
              ])
              .write();

            const results = [];

            for (const r of repos) {
              const owner = r.owner;
              const repo  = r.name;

              try {
                const repoData = await github.rest.repos.get({ owner, repo });
                const base = repoData.data.default_branch || 'main';

                // Check if file already exists
                let exists = true;
                let existingSha = null;
                try {
                  const existing = await github.rest.repos.getContent({ 
                    owner, 
                    repo, 
                    path: targetPath, 
                    ref: base 
                  });
                  existingSha = existing.data.sha;
                } catch (e) {
                  if (e.status === 404) exists = false;
                  else throw e;
                }

                if (exists) {
                  results.push({ repo: r.full, status: 'skipped:exists', message: 'Workflow already exists' });
                  continue;
                }

                const ts = new Date().toISOString().replace(/[:.]/g,'-');
                const branch = `chore/add-self-scan-${ts}`;

                if (dryRun) {
                  results.push({ repo: r.full, status: 'would-create-pr', branch, base });
                  continue;
                }

                // Get base ref
                const baseRef = await github.rest.git.getRef({ 
                  owner, 
                  repo, 
                  ref: `heads/${base}` 
                });
                const baseSha = baseRef.data.object.sha;

                // Create new branch
                await github.rest.git.createRef({ 
                  owner, 
                  repo, 
                  ref: `refs/heads/${branch}`, 
                  sha: baseSha 
                });

                // Create file in new branch
                await github.rest.repos.createOrUpdateFileContents({
                  owner,
                  repo,
                  path: targetPath,
                  message: prTitle,
                  content: b64,
                  branch
                });

                // Create PR
                const pr = await github.rest.pulls.create({
                  owner,
                  repo,
                  title: prTitle,
                  head: branch,
                  base,
                  body: prBody
                });

                results.push({ repo: r.full, status: 'pr-created', pr: pr.data.html_url });

              } catch (e) {
                const msg = e?.message?.split('\n')[0] || String(e);
                if (/Resource not accessible by integration/i.test(msg)) {
                  results.push({ 
                    repo: r.full, 
                    status: 'error:403', 
                    message: 'Resource not accessible (App not installed or missing permissions)' 
                  });
                } else {
                  results.push({ repo: r.full, status: 'error', message: msg });
                }
              }
            }

            const created = results.filter(r => r.status === 'pr-created').length;
            const skipped = results.filter(r => r.status === 'skipped:exists').length;
            const would   = results.filter(r => r.status === 'would-create-pr').length;
            const errors  = results.filter(r => r.status.startsWith('error')).length;

            await core.summary
              .addHeading('Deployment Results')
              .addTable([
                [{data:'Repo',header:true},{data:'Status',header:true},{data:'Details',header:true}],
                ...results.map(r => [r.repo, r.status, r.pr || r.message || ''])
              ])
              .addRaw(`\nPRs Created: ${created}  |  Skipped: ${skipped}  |  Dry-run: ${would}  |  Errors: ${errors}\n`)
              .write();
